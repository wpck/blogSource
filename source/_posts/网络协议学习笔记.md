---
title: 网络协议学习笔记
date: 2020-12-09 15:54:29
tags:
cover: ./img/11http.jpg
---
网络协议指的是计算机网络中互相通信的对等实体之间交换信息时必须遵守的规则的集合,TCP/IP是因特网的正式网络协议,TCP/IP协议不是某一个协议,而是一个协议族的统称,包括IP协议,TCP协议,http协议等;    
+ 网络协议三要素: 语义(要做什么), 语法(怎么做), 时序(做的顺序);
+ 由于网络节点之间的复杂性,正在制定协议是,通常把复杂成分分解成简单的成分,然后再把他们复合起来,最常用的复合技术是层次方式,网络结构的层次方式如下:
>每一层都规定有明确的服务及标准; 把用户的应用程序作为最高层; 除了最高层,中间的每一层都向上一层提供服务,同时又是下一层的用户; 把物理线路作为最底层,使用最高层传递进来的参数,提供最基础的服务;

### 层次划分
+ 国际标准化组织(ISO)提出了"开放系统互联参考模型",即 OSI/RM 模型, 自下而上分为7层: 物理层 >数据链路层 >网络层 >数据传输层> 会话层> 表示层> 应用层; 其中第4层完成数据传送服务,上面3层面向用户;
+ TCP/IP 协议分层模型: 网络接口层(物理层,数据链路层)> 网络层> 数据传输层> 应用层(会话层,表示层,应用层)
>物理层: 以太网,调制解调器等;   
>数据链路层: Wifi等;   
>网络层协议: IP(IPv4,IPv6)等;   
>传输层协议: TCP, UDP等;   
>应用层协议: Http, DNS, SSH等
### IP TCP协议
+ IP协议用于计算机之间的通信,IP协议是无连接的;
>每个计算机都必须有一个IP才能够连入因特网; 每个IP包必须包含一个地址才能发送到另一台计算机;
+ TCP协议用于应用程序之间的通信,TCP协议有固定的连接;
>当一个应用程序希望通过TCP与另一个应用程序通信时,会发出一个请求,这个请求必须被送到一个确切的地址,在双方"握手"之后,TCP将在两个应用程序之间建立一个全双工的通信; 全双工通信将占用两个计算机之间的通信线路,直到它被一方或双方关闭;   
>TCP负责将数据装入IP包,然后在他们到达时重新组合他们; IP负责将数据包发送至指定的接收计算机;
+ DNS服务器负责把域名解析为ip地址;
### TCP三次握手建立连接
TCP三次握手指的是:建立TCP连接时,需要与客户端与服务端发送3个包以确认连接的建立;   
>第一次握手: client将标志位SYN设置为 1,随机产生一个值 seq=j,并将改数据包发送给server,client进入 SYN_SENT 状态,等待server确认;   
>第二次握手: server收到数据包后,由 SYN=1 知道client请求建立连接,server将标志位SYN和ACK设置为 1, ack=j+1, 随机产生一个值 seq=k,并将该数据包发送给client以确认连接请求,server进入 SYN_RCVD 状态;   
>第三次握手: client收到确认后,检查ack是否为 j+1,ACK是否为 1,如果正确,将ACK设置为 1,ack为 k+1,并将数据包发送给server,server收到确认后,检查ack是否为 k+1,ACK是否为 1,如果正确则建立连接, client和server进入ESTABLISHED状态,可以进行数据传输了;   

简单来说就是:   
>客户端发送(SYN=j)包给服务端,进入SYN_SEND状态;      
>服务端收到客户端的SYN包,确认客户端的SYN(ack=j+1),同时自己也发送一个SYN包(SYN=k),发送给客户端(ACK包+SYN包),进入SYN_RCVD状态;     
>客户端收到服务端的数据包,向服务端发送确认报文(ack=k+1),客户端与服务器都进入ESTABLISHED状态,可以传输数据; 

SYN攻击
>server发送SYN+ACK包之后,未收到client的ACK包之前的TCP连接成为半连接状态; SYN攻击就是短时间内伪造大量不存在的ip地址,并向server不断的发送SYN包,server回复确认包,并等待client的确认,由于原地址是不存在的,server需要不断重发直至超时; 这些伪造的SYN包将长时间占用未连接队列,导致正常的请求因为队列满而被丢弃,从而引发网络堵塞甚至系统瘫痪;     
>检测SYN攻击的方式: 当server上有大量的半连接状态且源ip地址是随机的,可以判断为SYN攻击,执行 #netstat -nap | grep SYN_RECV 命令;
### TCP四次挥手终止连接
TCP四次挥手指的是: 终止TCP连接,需要客户端与服务器发送4个包以确认断开连接,由client或server任一方执行close来触发;由client执行close终止连接的过程如下:
>第一次挥手: client发送FIN,用来关闭client到server的数据传输,client进入FIN_WAIT_1状态;    
>第二次挥手: server收到FIN后,向client发送一个SYN包(ack=j+1),序号为收到序号+1(与SYN相同),服务端进入CLOSE_WAIT阶段;    
>第三次挥手: server发送FIN,用来关闭server向client的数据传输,服务器进入LAST_ACK状态;    
>第四次挥手: client收到FIN,client进入TIME_WAIT阶段,发送SYN包(ack=k+1)到服务端,序号为收到序号+1;server进入CLOSE状态,完成四次挥手;

+ 建立连时是3次握手,终止连接时是4次挥手   
>因为server处于listen状态下,在手到建立连接的SYN时,把ACK和SYN放在一个报文里发送给client;而关闭连接时,在收到对方的FIN后,仅仅表示对方不在发送数据了,而己方可能还未把所有所有数据都发送完毕,所以己方可以立即关闭,也可以发送一些数据给对方后,再发送FIN给对方表示同意现在关闭连接,因此己方的SYN和FIN一般会分开来发送;


